const std = @import("std");
const fmt = std.fmt;

// 640 ought to be enough for anybody.
var memory: [640]u8 = undefined;
var fba = std.heap.FixedBufferAllocator.init(&memory);
const allocator = fba.allocator();

// Random number generator
var rnd = std.rand.DefaultPrng.init(0);

// 2D Vector implementation
const Vec = @import("Vec.zig");
const V = Vec.new;

// TODO: Move this somewhere better
fn T(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) [3]Vec {
    return .{ V(x1, y1), V(x2, y2), V(x3, y3) };
}

// Particle implementation
const Particle = @import("Particle.zig");
const P = Particle.new;

// WASM-4
const w4 = @import("wasm4.zig");

// Global state
var s = State{};

const State = struct {
    si: u2 = 0, // Scene index
    x: i32 = 80, // Mouse X
    y: i32 = 80, // Mouse Y

    blf: u8 = 0, // Buttons pressed last frame
    btf: u8 = 0, // Buttons pressed this frame

    glf: u8 = 0, // Gamepad pressed last frame
    gtf: u8 = 0, // Gamepad pressed this frame

    life: i8 = 3, // Life
    score: u8 = 0, // Some sort of game score
    frame: u32 = 0,

    // The inputs
    buttons: *const u8 = w4.MOUSE_BUTTONS,
    gamepad: *const u8 = w4.GAMEPAD1,

    m: Vec = Vec.center(),
    lm: Vec = Vec.center(),

    scenes: [3]Scene = .{
        .{ .intro = Intro{} },
        .{ .game = Game{} },
        .{ .over = Over{} },
    },

    fn start(_: *State) void {
        trace(
            \\    ______ _______ _______ _______ _______ _______ ___ ___ _____  _______
            \\   |   __ |_     _|    |  |     __|       |     __|   |   |     ||_     _|
            \\  /|   __ <_|   |_|       |    |  |   -   |__     |\     /|       || #9|\
            \\.::|______|_______|__|____|_______|_______|_______| |___| |_______||___|::.
            \\
        );

        // Transition to the scene loaded from disk
        // defaulting to the OVER scene
        s.transition(s.load(OVER));
    }

    fn load(_: *State, default: u2) u2 {
        var si: u2 = default;

        _ = w4.diskr(@ptrCast(&si), @sizeOf(@TypeOf(si)));

        return si;
    }

    fn update(state: *State) !void {
        // Update mouse press on this and last frame
        state.btf = state.buttons.* & (state.buttons.* ^ state.blf);
        state.blf = state.buttons.*;

        state.gtf = state.gamepad.* & (state.gamepad.* ^ state.glf);
        state.glf = state.gamepad.*;

        if (state.buttons.* & w4.MOUSE_LEFT != 0) {
            // Update mouse position
            state.x = @intCast(w4.MOUSE_X.*);
            state.y = @intCast(w4.MOUSE_Y.*);

            if (state.x < 0) state.x = 0;
            if (state.y < 0) state.y = 0;
            if (state.x > 160) state.x = 160;
            if (state.y > 160) state.y = 160;

            state.m = V(@floatFromInt(state.x), @floatFromInt(state.y)).lerp(state.lm, 0.8);
            state.lm = state.m;
        }

        // Increment the frame counter
        state.frame +%= 1;

        // Update the scene specific state
        try state.scenes[state.si].update();
    }

    fn draw(state: *State) !void {
        // Draw the scene
        try state.scenes[s.si].draw();
    }

    fn mouseLeft(state: *State) bool {
        return state.btf & w4.MOUSE_LEFT != 0;
    }

    fn mouseMiddle(state: *State) bool {
        return state.btf & w4.MOUSE_MIDDLE != 0;
    }

    fn mouseRight(state: *State) bool {
        return state.btf & w4.MOUSE_RIGHT != 0;
    }

    fn button1(state: *State) bool {
        return state.gtf & w4.BUTTON_1 != 0;
    }

    fn button2(state: *State) bool {
        return state.gtf & w4.BUTTON_2 != 0;
    }

    fn transition(state: *State, sceneIndex: u2) void {
        w4.tracef("-== TRANSITION TO SCENE: [%d] ==-", @as(u8, sceneIndex));

        _ = try state.scenes[sceneIndex].enter();

        state.si = sceneIndex;
        state.save();
    }

    fn save(state: *State) void {
        // Save the scene index to disk
        var wrote = w4.diskw(@ptrCast(&state.si), @sizeOf(@TypeOf(state.si)));

        w4.tracef("WROTE %d", wrote);
    }
};

const Intro = struct {
    debugEnabled: bool = false,
    catLastPos: Vec = Vec.zero(),
    towerLastPos: Vec = Vec.center(),

    // Tangerine Noir
    // https://lospec.com/palette-list/tangerine-noir
    tangerineNoir: [4]u32 = .{
        0xfcfcfc, // White
        0x393541, // Gray
        0x191a1f, // Black
        0xee964b, // Tangerine
    },

    // Repeating version of Dream Haze 8
    // https://lospec.com/palette-list/dream-haze-8
    repeating: [15]u32 = .{
        0x3c42c4,
        0x6e51c8,
        0xa065cd,
        0xce79d2,
        0xd68fb8,
        0xdda2a3,
        0xeac4ae,
        0xf4dfbe,
        0xf4dfbe,
        0xeac4ae,
        0xdda2a3,
        0xd68fb8,
        0xce79d2,
        0xa065cd,
        0x6e51c8,
    },

    fn enter(intro: *Intro) !void {
        w4.PALETTE.* = intro.tangerineNoir;
    }

    fn update(intro: *Intro) !void {
        if (s.button2()) {
            intro.debugEnabled = !intro.debugEnabled;
        }

        w4.PALETTE.*[3] = intro.repeating[
            @mod(
                @divFloor(s.frame, 8),
                intro.repeating.len,
            )
        ];

        if (s.button1()) {
            s.transition(GAME);
        }
    }

    fn draw(intro: *Intro) !void {
        clear(BLACK);

        intro.bottom();

        color(BLACK);

        intro.scrollingTitle();

        const np = ([_]f32{ 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9 })[0..];

        // White cat
        var w: f32 = @floatFromInt(cat.width);
        var h: f32 = @floatFromInt(cat.height);
        var catOffset = V(@divFloor(w, 4), @divFloor(h, 2));

        var fframe: f32 = @floatFromInt(s.frame);
        var t: f32 = @abs(@mod(fframe, 1000) - 500);

        intro.catline(V(-20, 60), V(180, 80), 25, np, t / 500, catOffset);

        const mv = s.m;

        sizeline(V(30, 130), mv, 24, np, 0x23, 0x43);
        sizeline(V(130, 30), mv, 24, np, 0x23, 0x43);
        sizeline(V(30, 30), mv, 24, np, 0x23, 0x43);
        sizeline(V(130, 130), mv, 24, np, 0x23, 0x43);

        color(0x43);
        oval(mv.sub(V(20, 20)), 40, 40);
        color(0x4001);

        var pos = mv.sub(catOffset).sub(Vec.set(1));

        if (pos.x() < 80) {
            img(cat, pos, cat.flags | w4.BLIT_FLIP_X);
        } else {
            img(cat, pos, cat.flags);
        }

        var d: i32 = @intFromFloat(s.m.distance(Vec.center()));

        try intro.debug(.{ s.frame, s.x, s.y, d });
    }

    fn catline(intro: *Intro, a: Vec, b: Vec, size: u32, points: []const f32, t: f32, catOffset: Vec) void {
        const catPos = a.lerp(b, t).sub(catOffset);
        const fsize: f32 = @floatFromInt(size);
        const offset = Vec.set(@divFloor(fsize, 2));

        for (0.., points) |i, p| {
            if (@mod(i, 2) == 0) {
                color(0x23);
            } else {
                color(0x42);
            }

            rect(a.lerp(b, p).sub(offset), size, size);
        }

        color(0x4001);
        if (intro.catLastPos.x() < catPos.x()) {
            img(cat, catPos, cat.flags | w4.BLIT_FLIP_X);
        } else {
            img(cat, catPos, cat.flags);
        }

        //dump(catPos.data, 10, 10);

        intro.catLastPos = catPos;
    }

    fn scrollingTitle(_: *Intro) void {
        var offset: i32 = @intCast(@mod(@divFloor(s.frame, 2), 320));

        title("_  _  _  _  _", 180 + -offset - 13, 14, GRAY, PRIMARY);
        title("-  -  -  -  -", 180 + -offset - 12, 16, GRAY, PRIMARY);
        title("I  N  T  R  O", 180 + -offset - 18, 16, GRAY, PRIMARY);
    }

    fn debug(intro: *Intro, args: anytype) !void {
        if (!intro.debugEnabled) {
            return;
        }

        // Gray cat
        color(0x4002);
        image(cat, 110, 132, cat.flags | w4.BLIT_FLIP_X);

        const str = try fmt.allocPrint(allocator,
            \\FRAME: {d}
            \\MOUSE: [{d}][{d}]
            \\DEBUG: {any}
        , args);
        defer allocator.free(str);

        // trace(str);
        title(str, 20, 130, GRAY, WHITE);
    }

    fn bottom(_: *Intro) void {
        color(0x4332);

        image(death, -30, 99, death.flags | w4.BLIT_ROTATE | w4.BLIT_FLIP_X);
        image(death, 0, 99, death.flags | w4.BLIT_ROTATE | w4.BLIT_FLIP_X);
        image(death, 30, 99, death.flags | w4.BLIT_ROTATE | w4.BLIT_FLIP_X);
        image(death, 60, 99, death.flags | w4.BLIT_ROTATE | w4.BLIT_FLIP_X);
        image(death, 90, 99, death.flags | w4.BLIT_ROTATE | w4.BLIT_FLIP_X);
        image(death, 120, 99, death.flags | w4.BLIT_ROTATE | w4.BLIT_FLIP_X);
    }
};

const Game = struct {
    // Tangerine Noir
    // https://lospec.com/palette-list/tangerine-noir
    palette: [4]u32 = .{
        0xfcfcfc, // White
        0x393541, // Gray
        0x191a1f, // Black
        0xee964b, // Tangerine
    },

    startup: Tone = Tone{
        .freq1 = 240,
        .freq2 = 680,
        .attack = 0,
        .decay = 35,
        .sustain = 51,
        .release = 117,
        .peak = 26,
        .volume = 6,
        .mode = 0,
    },

    died: Tone = Tone{
        .freq1 = 90,
        .freq2 = 40,
        .attack = 10,
        .decay = 0,
        .sustain = 15,
        .release = 25,
        .peak = 0,
        .volume = 90,
        .mode = 1,
    },

    fn enter(game: *Game) !void {
        w4.PALETTE.* = game.palette;

        s.life = 3;

        game.startup.play(0);
        game.startup.play(1);
        game.startup.play(2);
    }

    fn update(game: *Game) !void {
        if (s.button1()) {
            s.life -= 1;
            s.score += 1;

            w4.tracef("life %d score %d", s.life, s.score);
        }

        if (s.life == 0) {
            game.died.play(2);
            s.transition(OVER);
        }
    }

    fn draw(_: *Game) !void {
        clear(BLACK);

        color(0x31);
        text("GAME", 8, 6);

        var i: i32 = 0;

        while (i <= s.life) : (i += 1) {
            const fi: f32 = @floatFromInt(i);

            color(0x34);
            rect(V(10, 30 - fi), 10, 10);
        }

        triangle(T(80, 30, 100, 15, 120, 40), PRIMARY);
        triangle(T(80, 30, 120, 40, 90, 50), PRIMARY);

        triangle(T(80, 90, 100, 150, 10, 150), WHITE);
        triangle(T(80, 90, 155, 150, 100, 150), GRAY);
    }
};

const Over = struct {
    // Tangerine Noir
    // https://lospec.com/palette-list/tangerine-noir
    palette: [4]u32 = .{
        0xfcfcfc, // White
        0x393541, // Gray
        0x191a1f, // Black
        0xee964b, // Tangerine
    },

    sound: Tone = Tone{
        .freq1 = 50,
        .freq2 = 40,
        .attack = 25,
        .decay = 168,
        .sustain = 0,
        .release = 25,
        .peak = 0,
        .volume = 2,
        .mode = 3,
    },

    snowParticlesOver: [64]Particle = [_]Particle{.{}} ** 64,
    snowParticlesBehind: [128]Particle = [_]Particle{.{}} ** 128,

    //snowParticles: [1]Particle = [_]Particle{.{}} ** 1,

    deathFlipped: bool = false,
    pressFlipped: bool = false,

    fn enter(over: *Over) !void {
        w4.PALETTE.* = over.palette;

        // Random positions for the snow particles over
        for (0.., over.snowParticlesOver) |i, _| {
            over.snowParticlesOver[i] = P(
                rnd.random().float(f32) * 160,
                rnd.random().float(f32) * 160,
                @floatFromInt(45),
                5 + rnd.random().float(f32) * 15,
                10,
            );
        }

        // Random positions for the snow particles behind
        for (0.., over.snowParticlesBehind) |i, _| {
            over.snowParticlesBehind[i] = P(
                rnd.random().float(f32) * 160,
                rnd.random().float(f32) * 160,
                @floatFromInt(45),
                5 + rnd.random().float(f32) * 15,
                10,
            );
        }
    }

    fn update(over: *Over) !void {
        if (s.button1()) {
            s.transition(INTRO);
        }

        over.updateSnow();

        if (every(120)) over.deathFlipped = !over.deathFlipped;
        if (every(30)) over.pressFlipped = !over.pressFlipped;
        if (every(400)) over.sound.play(2);
    }

    fn draw(over: *Over) !void {
        clear(GRAY);

        color(WHITE);
        rect(V(0, 130), 160, 30);

        var flags = death.flags;

        if (over.deathFlipped) {
            flags |= w4.BLIT_FLIP_X;
        }

        over.snowBehind();

        const fg: u16 = if (over.pressFlipped) PRIMARY else WHITE;

        title("PRESS\n{X}to\nINTRO", 104, 105, BLACK, fg);

        color(0x20);
        image(pine, 142, 107, pine.flags | w4.BLIT_FLIP_X);

        color(0x10);
        image(pine, 142, 106, pine.flags | w4.BLIT_FLIP_X);

        title("|:.:* .*.,*_*", -4, 125, GRAY, GRAY);
        title("*_*,.**,.|::", -7, 123, GRAY, GRAY);

        color(0x4301);
        image(death, 40, 15, flags);

        color(0x4302);
        image(coffee, 38, 134, coffee.flags);
        color(BLACK);
        rect(V(43, 137), 2, 2);

        color(0x20);
        image(pine, -10, 116, pine.flags);

        color(0x10);
        image(pine, -10, 115, pine.flags);
        over.snowOver();

        title("The SYLT is OVER!!", 8, 3, PRIMARY, WHITE);
    }

    fn snowBehind(over: *Over) void {
        for (0.., over.snowParticlesBehind) |i, p| {
            if (@mod(i, 5) == 0) {
                color(GRAY);
                ppx(p.add(V(1, 1)));

                color(WHITE);
                ppx(p.add(V(1, -1)));
                if (@mod(i, 4) == 0) {
                    ppx(p.add(V(-1, -1)));
                    ppx(p.add(V(-1, 1)));

                    if (@mod(i, 3) == 0) {
                        ppx(p.add(V(1, 1)));
                    }
                }
            }

            ppx(p);

            color(WHITE);
            vpx(p.newpos(-0.1));
            vpx(p.newpos(-0.15));

            color(GRAY);
            vpx(p.newpos(-0.2));
        }
    }

    fn snowOver(over: *Over) void {
        for (0.., over.snowParticlesOver) |i, p| {
            if (@mod(i, 5) == 0) {
                color(GRAY);
                ppx(p.add(V(1, 1)));

                color(WHITE);
                ppx(p.add(V(1, -1)));
                if (@mod(i, 4) == 0) {
                    ppx(p.add(V(-1, -1)));
                    ppx(p.add(V(-1, 1)));

                    if (@mod(i, 3) == 0) {
                        ppx(p.add(V(1, 1)));
                    }
                }
            }

            ppx(p);

            color(WHITE);
            vpx(p.newpos(-0.1));
            vpx(p.newpos(-0.15));

            color(GRAY);
            vpx(p.newpos(-0.2));
        }
    }

    fn updateSnow(over: *Over) void {
        for (0.., over.snowParticlesOver) |i, p| {
            var n = p.update(0.1);

            n.position.data[0] = @mod(n.position.data[0], 165);
            n.position.data[1] = @mod(n.position.data[1], 165);

            if (n.life < 0) {
                n.life = rnd.random().float(f32) * 10;
            }

            over.snowParticlesOver[i] = n;
        }

        for (0.., over.snowParticlesBehind) |i, p| {
            var n = p.update(0.1);

            n.position.data[0] = @mod(n.position.data[0], 165);
            n.position.data[1] = @mod(n.position.data[1], 165);

            if (n.life < 0) {
                n.life = rnd.random().float(f32) * 10;
            }

            over.snowParticlesBehind[i] = n;
        }
    }
};

const Scene = union(enum) {
    intro: Intro,
    game: Game,
    over: Over,

    fn enter(self: *Scene) !void {
        switch (self.*) {
            inline else => |*scene| try scene.enter(),
        }
    }

    fn update(self: *Scene) !void {
        switch (self.*) {
            inline else => |*scene| try scene.update(),
        }
    }

    fn draw(self: *Scene) !void {
        switch (self.*) {
            inline else => |*scene| try scene.draw(),
        }
    }
};

fn every(f: u32) bool {
    return @mod(s.frame, f) == 0;
}

// Tone that can play itself
const Tone = struct {
    freq1: u32 = 0,
    freq2: u32 = 0,
    attack: u32 = 0,
    decay: u32 = 0,
    sustain: u32 = 0,
    release: u32 = 0,
    peak: u32 = 0,
    volume: u32 = 0,
    mode: u32 = 0,
    pan: u32 = 0,

    fn play(t: Tone, channel: u32) void {
        const frequency = t.freq1 | (t.freq2 << 16);
        const duration = (t.attack << 24) | (t.decay << 16) | t.sustain | (t.release << 8);
        const volume = (t.peak << 8) | t.volume;
        const flags = channel | (t.mode << 2) | (t.pan << 4);

        w4.tone(
            frequency,
            duration,
            volume,
            flags,
        );
    }
};

// The colors
const WHITE: u16 = 0x0001;
const GRAY: u16 = 0x0002;
const BLACK: u16 = 0x0003;
const PRIMARY: u16 = 0x0004;

// The scene indexes
const INTRO: u2 = 0;
const GAME: u2 = 1;
const OVER: u2 = 2;

// Proxy functions for w4
fn text(str: []const u8, x: i32, y: i32) void {
    w4.text(str, x, y);
}

fn title(str: []const u8, x: i32, y: i32, bg: u16, fg: u16) void {
    color(bg);
    text(str, x, y);
    color(fg);
    text(str, x + 1, y + 1);
}

fn line(a: Vec, b: Vec) void {
    w4.line(
        @intFromFloat(a.x()),
        @intFromFloat(a.y()),
        @intFromFloat(b.x()),
        @intFromFloat(b.y()),
    );
}

fn oval(pos: Vec, width: u32, height: u32) void {
    w4.oval(@intFromFloat(pos.x()), @intFromFloat(pos.y()), width, height);
}

fn rect(pos: Vec, width: u32, height: u32) void {
    w4.rect(@intFromFloat(pos.x()), @intFromFloat(pos.y()), width, height);
}

fn blit(sprite: [*]const u8, x: i32, y: i32, width: u32, height: u32, flags: u32) void {
    w4.blit(sprite, x, y, width, height, flags);
}

fn image(m: Sprite, x: i32, y: i32, flags: u32) void {
    blit(m.sprite, x, y, m.width, m.height, flags);
}

fn img(m: Sprite, v: Vec, flags: u32) void {
    blit(m.sprite, @intFromFloat(v.x()), @intFromFloat(v.y()), m.width, m.height, flags);
}

fn color(c: u16) void {
    w4.DRAW_COLORS.* = c;
}

fn clear(c: u8) void {
    for (w4.FRAMEBUFFER) |*x| {
        x.* = c - 1 | (c - 1 << 2) | (c - 1 << 4) | (c - 1 << 6);
    }
}

fn vpx(v: Vec) void {
    pixel(@intFromFloat(v.x()), @intFromFloat(v.y()));
}

fn ppx(p: Particle) void {
    vpx(p.position);
}

fn pixel(x: i32, y: i32) void {
    if (x < 0 or x > 160 or y < 0 or y > 160) {
        return;
    }

    const ux: usize = @intCast(x);
    const uy: usize = @intCast(y);
    const idx: usize = (uy * 160 + ux) >> 2;
    const sx: u3 = @intCast(x);
    const shift = (sx & 0b11) * 2;
    const mask = @as(u8, 0b11) << shift;
    const palette_color: u8 = @intCast(w4.DRAW_COLORS.* & 0b1111);

    if (palette_color == 0) {
        return;
    }

    const c = (palette_color - 1) & 0b11;

    w4.FRAMEBUFFER[idx] = (c << shift) | (w4.FRAMEBUFFER[idx] & ~mask);
}

fn centroid(t: [3]Vec) Vec {
    return V(
        (t[0].x() + t[1].x() + t[2].x()) / 3,
        (t[0].y() + t[1].y() + t[2].y()) / 3,
    );
}

fn triangle(t: [3]Vec, fg: u16) void {
    const xMin: usize = @intFromFloat(@min(@min(t[0].x(), t[1].x()), t[2].x()));
    const yMin: usize = @intFromFloat(@min(@min(t[0].y(), t[1].y()), t[2].y()));
    const xMax: usize = @intFromFloat(@max(@max(t[0].x(), t[1].x()), t[2].x()));
    const yMax: usize = @intFromFloat(@max(@max(t[0].y(), t[1].y()), t[2].y()));

    color(fg);

    const bias0: f32 = if (isTopLeft(t[1], t[2])) 0 else -0.0001;
    const bias1: f32 = if (isTopLeft(t[2], t[0])) 0 else -0.0001;
    const bias2: f32 = if (isTopLeft(t[0], t[1])) 0 else -0.0001;

    const area = Vec.cross(t[0], t[1], t[2]);
    const c = centroid(t);

    for (yMin..yMax) |y| {
        for (xMin..xMax) |x| {
            var p = V(@floatFromInt(x), @floatFromInt(y));

            const w0 = p.cross(t[0], t[1]) + bias0;
            const w1 = p.cross(t[1], t[2]) + bias1;
            const w2 = p.cross(t[2], t[0]) + bias2;

            const is_inside = (w0 >= 0) and (w1 >= 0) and (w2 >= 0);

            if (is_inside) {
                const alpha = w0 / area;
                const beta = w1 / area;
                const gamma = w2 / area;

                if (beta > 0.3) {
                    //color(WHITE);
                }

                if (beta < 0.4) {
                    //color(GRAY);
                }

                if (alpha > 0.7 or gamma < 0.1) {
                    //color(WHITE);
                }

                const d = p.distance(c);

                if (d < @abs(@as(f32, @floatFromInt(@mod(s.frame, 20))) / 32 - 16) and @mod(x, 1) == 0 and @mod(y, 2) == 1) {
                    color(BLACK);
                    if (d < 11 and @mod(s.frame, 24) < 12) {
                        color(PRIMARY);
                    }

                    if (@sin(@as(f32, @floatFromInt(x ^ y))) < 0) {
                        color(WHITE);
                    }
                } else {
                    color(GRAY);
                }

                pixel(@intCast(x), @intCast(y));
            }
        }
    }
}

fn isTopLeft(a: Vec, b: Vec) bool {
    var edge = V(b.x() - a.x(), b.y() - a.y());
    var is_top_edge = (edge.y() == 0) and (edge.x() > 0);
    var is_left_edge = edge.y() < 0;

    return is_top_edge or is_left_edge;
}

fn dotline(a: Vec, b: Vec, dotSize: u32, points: []const f32) void {
    const fsize: f32 = @floatFromInt(dotSize);
    const offset = Vec.set(@divFloor(fsize, 2));

    for (points) |p| {
        oval(a.lerp(b, p).sub(offset), dotSize, dotSize);
    }
}

fn sizeline(a: Vec, b: Vec, dotSize: u32, points: []const f32, c1: u16, c2: u16) void {
    for (0.., points) |i, p| {
        const size = dotSize * i / 4;
        const fsize: f32 = @floatFromInt(size);
        const offset = Vec.set(@divFloor(fsize, 2));

        if (@mod(i, 2) == 0) {
            color(c2);
        } else {
            color(c1);
        }

        rect(a.lerp(b, p).sub(offset), size, size);
    }

    color(0x4444);

    if (a.eql(V(30, 30))) {
        dotline(a, b.offset(-25, -25), 3, points);
    }

    if (a.eql(V(130, 30))) {
        dotline(a, b.offset(25, -25), 3, points);
    }

    if (a.eql(V(30, 130))) {
        dotline(a, b.offset(-25, 25), 3, points);
    }

    if (a.eql(V(130, 130))) {
        if (b.x() < 95 or b.y() < 96) {
            dotline(a, b.offset(25, 25), 3, points);
        }
    }
}

fn trace(x: []const u8) void {
    w4.trace(x);
}

fn string(arg: []const u8, x: i32, y: i32, bg: u16, fg: u16) !void {
    const str = try fmt.allocPrint(allocator, "{s}", .{arg});
    defer allocator.free(str);

    trace(str);
    title(str, x, y, bg, fg);
}

fn any(arg: anytype, x: i32, y: i32, bg: u16, fg: u16) !void {
    const str = try fmt.allocPrint(allocator, "{any}", .{arg});
    defer allocator.free(str);

    trace(str);
    title(str, x, y, bg, fg);
}

fn dump(arg: anytype, x: i32, y: i32) void {
    _ = any(arg, x, y, BLACK, PRIMARY) catch unreachable;
}

const Sprite = struct {
    sprite: [*]const u8,
    width: u32,
    height: u32,
    flags: u32 = w4.BLIT_2BPP,
};

pub const death = Sprite{
    .sprite = ([2856]u8{ 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0x80, 0x00, 0x02, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x00, 0x02, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x00, 0x00, 0x2a, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x56, 0xaa, 0xa0, 0x00, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x5a, 0xaa, 0x00, 0x2a, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x00, 0x00, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x6a, 0xa8, 0x02, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0x80, 0x00, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0xaa, 0xa0, 0x2a, 0x95, 0x55, 0x55, 0x55, 0x56, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x6a, 0xa8, 0x00, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0xaa, 0x80, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x55, 0xaa, 0x80, 0xaa, 0xaa, 0x95, 0x55, 0x56, 0xaa, 0x0a, 0xa5, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x5a, 0xa8, 0xaa, 0xaa, 0x95, 0x55, 0x56, 0xa8, 0x2a, 0x95, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0x55, 0x55, 0x5a, 0xa0, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0x55, 0x55, 0x6a, 0x8a, 0xa5, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x5e, 0xaa, 0xaa, 0x55, 0x55, 0x6a, 0x2a, 0x95, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0xa8, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0xa2, 0xa5, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x56, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x56, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x5a, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x5a, 0xa5, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x70, 0x35, 0x55, 0x55, 0x6a, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x70, 0x35, 0x55, 0x55, 0x65, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xa8, 0x00, 0x0a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xaa, 0xaa, 0xa9, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xa9, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xaa, 0xaa, 0x70, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa0, 0x0a, 0xaa, 0xaa, 0x00, 0x02, 0xaa, 0xaa, 0xa0, 0x02, 0xaa, 0xa9, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa0, 0x2a, 0xaa, 0xaa, 0x80, 0x0a, 0xaa, 0xaa, 0xa8, 0x02, 0xaa, 0xa9, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa0, 0x2a, 0xaa, 0xaa, 0x80, 0x0a, 0xaa, 0xaa, 0xa8, 0x02, 0xaa, 0xa9, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa0, 0x2a, 0xaa, 0xaa, 0x80, 0x0a, 0xaa, 0xaa, 0xa8, 0x0a, 0xaa, 0xa9, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x2a, 0xaa, 0xaa, 0x80, 0x0a, 0xaa, 0xaa, 0xa8, 0x0a, 0xaa, 0xa9, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x2a, 0xaa, 0xaa, 0x80, 0x0a, 0xaa, 0xaa, 0xa8, 0x0a, 0xaa, 0xa5, 0xc0, 0xd5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x2a, 0xaa, 0xaa, 0x80, 0x0a, 0xaa, 0xaa, 0xa8, 0x0a, 0xaa, 0xa5, 0xc3, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x0a, 0xaa, 0xaa, 0x00, 0x02, 0xaa, 0xaa, 0xa0, 0x0a, 0xaa, 0xa7, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xa8, 0x02, 0xaa, 0xa8, 0x00, 0x00, 0xaa, 0xaa, 0x80, 0x2a, 0xaa, 0xa7, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0x00, 0xaa, 0xa0, 0x02, 0x00, 0x2a, 0xaa, 0x00, 0xaa, 0xaa, 0xa7, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0x80, 0x2a, 0x80, 0x0a, 0x80, 0x0a, 0xa8, 0x02, 0xaa, 0xaa, 0x97, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xa0, 0x00, 0x00, 0x28, 0xa0, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0x97, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xa8, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x2a, 0xaa, 0xaa, 0x97, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0x57, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xaa, 0x57, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xa9, 0x57, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0xa5, 0x57, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xa8, 0x02, 0x00, 0x80, 0x20, 0x0a, 0xaa, 0xaa, 0xa5, 0x57, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0x0a, 0x00, 0x80, 0x28, 0x2a, 0xaa, 0xaa, 0x95, 0x57, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x82, 0xa0, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0xa8, 0x2a, 0x0a, 0xaa, 0xaa, 0xaa, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x20, 0x08, 0x02, 0xaa, 0xaa, 0xa9, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0xa5, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x00, 0x00, 0x02, 0xaa, 0xaa, 0x95, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0x0a, 0xaa, 0xaa, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x5c, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x5c, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x5c, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x5c, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa5, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x70, 0x35, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x6a, 0xa5, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa2, 0x80, 0x09, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x80, 0x02, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x80, 0x09, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x80, 0x02, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x80, 0x00, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa2, 0x80, 0x02, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x2a, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x09, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x25, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xea, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xc3, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xc3, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xc3, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xc3, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x9b, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0x03, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xac, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xac, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xac, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xac, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xac, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xac, 0x0d, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x39, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x3a, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x3a, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x3a, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x3a, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x3a, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa0, 0x0a, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x95, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 })[0..],
    .width = 84,
    .height = 136,
};

pub const cat = Sprite{
    .sprite = ([27]u8{ 0x51, 0x45, 0x55, 0x40, 0x05, 0x55, 0x11, 0x05, 0x51, 0x0c, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x44, 0x54, 0x45 })[0..],
    .width = 12,
    .height = 9,
};

pub const coffee = Sprite{
    .sprite = ([40]u8{ 0x55, 0x54, 0x15, 0x55, 0x55, 0x54, 0x45, 0x55, 0x55, 0x40, 0x01, 0x55, 0x55, 0x14, 0x00, 0x55, 0x55, 0xd4, 0x00, 0x55, 0x55, 0xeb, 0x03, 0x55, 0x5a, 0xaf, 0xfe, 0xa9, 0xaa, 0xaa, 0xaa, 0xa5, 0x5a, 0x6a, 0xaa, 0x55, 0x6a, 0xa9, 0x55, 0x55 })[0..],
    .width = 16,
    .height = 10,
};

pub const pine = Sprite{
    .sprite = ([128]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x1f, 0xf1, 0x80, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0x80, 0x03, 0xff, 0xff, 0xd0, 0x01, 0xff, 0xff, 0xa0, 0x01, 0xff, 0xff, 0x80, 0x02, 0x3f, 0xfe, 0x00, 0x00, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0xf0, 0x01, 0xff, 0xff, 0xb0, 0x01, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xa0, 0x01, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xf0, 0x11, 0xff, 0xff, 0x9c, 0x01, 0x3f, 0xff, 0xf0, 0x03, 0xff, 0xff, 0xe0 })[0..],
    .width = 32,
    .height = 32,
    .flags = w4.BLIT_1BPP,
};

//
// Exported functions for the WASM-4 game loop
//

export fn start() void {
    s.start();
}

export fn update() void {
    // Update the state
    s.update() catch unreachable;

    // Draw the state
    s.draw() catch unreachable;
}
